{"ast":null,"code":"export function bias(val) {\n  const c = 0.501;\n  const x = Math.abs(val);\n  return Math.sign(val) * (x / ((1 / c - 2) * (1 - x) + 1));\n}\nexport function calculateUpdatedOffset(_ref) {\n  let {\n    selectedElement,\n    containerSize,\n    contentSize,\n    isRtl,\n    currentScrollOffset,\n    isHorizontal\n  } = _ref;\n  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;\n  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;\n  const adjustedOffsetStart = isRtl ? contentSize - offsetStart - clientSize : offsetStart;\n\n  if (isRtl) {\n    currentScrollOffset = -currentScrollOffset;\n  }\n\n  const totalSize = containerSize + currentScrollOffset;\n  const itemOffset = clientSize + adjustedOffsetStart;\n  const additionalOffset = clientSize * 0.4;\n\n  if (adjustedOffsetStart <= currentScrollOffset) {\n    currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0);\n  } else if (totalSize <= itemOffset) {\n    currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize);\n  }\n\n  return isRtl ? -currentScrollOffset : currentScrollOffset;\n}\nexport function calculateCenteredOffset(_ref2) {\n  let {\n    selectedElement,\n    containerSize,\n    contentSize,\n    isRtl,\n    isHorizontal\n  } = _ref2;\n  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;\n  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;\n\n  if (isRtl) {\n    const offsetCentered = contentSize - offsetStart - clientSize / 2 - containerSize / 2;\n    return -Math.min(contentSize - containerSize, Math.max(0, offsetCentered));\n  } else {\n    const offsetCentered = offsetStart + clientSize / 2 - containerSize / 2;\n    return Math.min(contentSize - containerSize, Math.max(0, offsetCentered));\n  }\n}","map":{"version":3,"mappings":"AAAA,OAAO,SAASA,IAAT,CAAeC,GAAf,EAA4B;EACjC,MAAMC,CAAC,GAAG,KAAV;EACA,MAAMC,CAAC,GAAGC,IAAI,CAACC,GAALD,CAASH,GAATG,CAAV;EACA,OAAOA,IAAI,CAACE,IAALF,CAAUH,GAAVG,KAAkBD,CAAC,IAAI,CAAC,IAAID,CAAJ,GAAQ,CAAT,KAAe,IAAIC,CAAnB,IAAwB,CAA5B,CAAnBC,CAAP;AACD;AAED,OAAO,SAASG,sBAAT,OAcI;EAAA,IAd6B;IACtCC,eADsC;IAEtCC,aAFsC;IAGtCC,WAHsC;IAItCC,KAJsC;IAKtCC,mBALsC;IAMtCC;EANsC,IAc7BC;EACT,MAAMC,UAAU,GAAGF,YAAY,GAAGL,eAAe,CAACQ,WAAnB,GAAiCR,eAAe,CAACS,YAAhF;EACA,MAAMC,WAAW,GAAGL,YAAY,GAAGL,eAAe,CAACW,UAAnB,GAAgCX,eAAe,CAACY,SAAhF;EACA,MAAMC,mBAAmB,GAAGV,KAAK,GAAID,WAAW,GAAGQ,WAAdR,GAA4BK,UAAhC,GAA8CG,WAA/E;;EAEA,IAAIP,KAAJ,EAAW;IACTC,mBAAmB,GAAG,CAACA,mBAAvBA;EACD;;EAED,MAAMU,SAAS,GAAGb,aAAa,GAAGG,mBAAlC;EACA,MAAMW,UAAU,GAAGR,UAAU,GAAGM,mBAAhC;EACA,MAAMG,gBAAgB,GAAGT,UAAU,GAAG,GAAtC;;EAEA,IAAIM,mBAAmB,IAAIT,mBAA3B,EAAgD;IAC9CA,mBAAmB,GAAGR,IAAI,CAACqB,GAALrB,CAASiB,mBAAmB,GAAGG,gBAA/BpB,EAAiD,CAAjDA,CAAtBQ;EADF,OAEO,IAAIU,SAAS,IAAIC,UAAjB,EAA6B;IAClCX,mBAAmB,GAAGR,IAAI,CAACsB,GAALtB,CAASQ,mBAAmB,IAAIU,SAAS,GAAGC,UAAZD,GAAyBE,gBAA7B,CAA5BpB,EAA4EM,WAAW,GAAGD,aAA1FL,CAAtBQ;EACD;;EAED,OAAOD,KAAK,GAAG,CAACC,mBAAJ,GAA0BA,mBAAtC;AACD;AAED,OAAO,SAASe,uBAAT,QAYI;EAAA,IAZ8B;IACvCnB,eADuC;IAEvCC,aAFuC;IAGvCC,WAHuC;IAIvCC,KAJuC;IAKvCE;EALuC,IAY9Be;EACT,MAAMb,UAAU,GAAGF,YAAY,GAAGL,eAAe,CAACQ,WAAnB,GAAiCR,eAAe,CAACS,YAAhF;EACA,MAAMC,WAAW,GAAGL,YAAY,GAAGL,eAAe,CAACW,UAAnB,GAAgCX,eAAe,CAACY,SAAhF;;EAEA,IAAIT,KAAJ,EAAW;IACT,MAAMkB,cAAc,GAAGnB,WAAW,GAAGQ,WAAdR,GAA4BK,UAAU,GAAG,CAAzCL,GAA6CD,aAAa,GAAG,CAApF;IACA,OAAO,CAACL,IAAI,CAACsB,GAALtB,CAASM,WAAW,GAAGD,aAAvBL,EAAsCA,IAAI,CAACqB,GAALrB,CAAS,CAATA,EAAYyB,cAAZzB,CAAtCA,CAAR;EAFF,OAGO;IACL,MAAMyB,cAAc,GAAGX,WAAW,GAAGH,UAAU,GAAG,CAA3BG,GAA+BT,aAAa,GAAG,CAAtE;IACA,OAAOL,IAAI,CAACsB,GAALtB,CAASM,WAAW,GAAGD,aAAvBL,EAAsCA,IAAI,CAACqB,GAALrB,CAAS,CAATA,EAAYyB,cAAZzB,CAAtCA,CAAP;EACD;AACF","names":["bias","val","c","x","Math","abs","sign","calculateUpdatedOffset","selectedElement","containerSize","contentSize","isRtl","currentScrollOffset","isHorizontal","_ref","clientSize","clientWidth","clientHeight","offsetStart","offsetLeft","offsetTop","adjustedOffsetStart","totalSize","itemOffset","additionalOffset","max","min","calculateCenteredOffset","_ref2","offsetCentered"],"sources":["../../../src/components/VSlideGroup/helpers.ts"],"sourcesContent":["export function bias (val: number) {\n  const c = 0.501\n  const x = Math.abs(val)\n  return Math.sign(val) * (x / ((1 / c - 2) * (1 - x) + 1))\n}\n\nexport function calculateUpdatedOffset ({\n  selectedElement,\n  containerSize,\n  contentSize,\n  isRtl,\n  currentScrollOffset,\n  isHorizontal,\n}: {\n  selectedElement: HTMLElement\n  containerSize: number\n  contentSize: number\n  isRtl: boolean\n  currentScrollOffset: number\n  isHorizontal: boolean\n}): number {\n  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight\n  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop\n  const adjustedOffsetStart = isRtl ? (contentSize - offsetStart - clientSize) : offsetStart\n\n  if (isRtl) {\n    currentScrollOffset = -currentScrollOffset\n  }\n\n  const totalSize = containerSize + currentScrollOffset\n  const itemOffset = clientSize + adjustedOffsetStart\n  const additionalOffset = clientSize * 0.4\n\n  if (adjustedOffsetStart <= currentScrollOffset) {\n    currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0)\n  } else if (totalSize <= itemOffset) {\n    currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize)\n  }\n\n  return isRtl ? -currentScrollOffset : currentScrollOffset\n}\n\nexport function calculateCenteredOffset ({\n  selectedElement,\n  containerSize,\n  contentSize,\n  isRtl,\n  isHorizontal,\n}: {\n  selectedElement: HTMLElement\n  containerSize: number\n  contentSize: number\n  isRtl: boolean\n  isHorizontal: boolean\n}): number {\n  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight\n  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop\n\n  if (isRtl) {\n    const offsetCentered = contentSize - offsetStart - clientSize / 2 - containerSize / 2\n    return -Math.min(contentSize - containerSize, Math.max(0, offsetCentered))\n  } else {\n    const offsetCentered = offsetStart + clientSize / 2 - containerSize / 2\n    return Math.min(contentSize - containerSize, Math.max(0, offsetCentered))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}