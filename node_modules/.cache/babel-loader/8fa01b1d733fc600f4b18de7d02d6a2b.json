{"ast":null,"code":"export function useForwardRef(target) {\n  for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    refs[_key - 1] = arguments[_key];\n  }\n\n  return new Proxy(target, {\n    get(target, key) {\n      if (Reflect.has(target, key)) {\n        return Reflect.get(target, key);\n      }\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          const val = Reflect.get(ref.value, key);\n          return typeof val === 'function' ? val.bind(ref.value) : val;\n        }\n      }\n    },\n\n    getOwnPropertyDescriptor(target, key) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n      if (descriptor) return descriptor; // Check each ref's own properties\n\n      for (const ref of refs) {\n        if (!ref.value) continue;\n        const descriptor = Reflect.getOwnPropertyDescriptor(ref.value, key);\n        if (descriptor) return descriptor;\n      } // Recursive search up each ref's prototype\n\n\n      for (const ref of refs) {\n        let obj = ref.value && Object.getPrototypeOf(ref.value);\n\n        while (obj) {\n          const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n          if (descriptor) return descriptor;\n          obj = Object.getPrototypeOf(obj);\n        }\n      }\n\n      return undefined;\n    }\n\n  });\n}","map":{"version":3,"mappings":"AAGA,OAAO,SAASA,aAAT,CACLC,MADK,EAG0C;EAAA,kCAD5CC,IAC4C;IAD5CA,IAC4C,UAD5CA,GAC4CC,eAD5CD;EAC4C;;EAC/C,OAAO,IAAIE,KAAJ,CAAUH,MAAV,EAAkB;IACvBI,GAAG,CAAEJ,MAAF,EAAUK,GAAV,EAAe;MAChB,IAAIC,OAAO,CAACC,GAARD,CAAYN,MAAZM,EAAoBD,GAApBC,CAAJ,EAA8B;QAC5B,OAAOA,OAAO,CAACF,GAARE,CAAYN,MAAZM,EAAoBD,GAApBC,CAAP;MACD;;MACD,KAAK,MAAME,GAAX,IAAkBP,IAAlB,EAAwB;QACtB,IAAIO,GAAG,CAACC,KAAJD,IAAaF,OAAO,CAACC,GAARD,CAAYE,GAAG,CAACC,KAAhBH,EAAuBD,GAAvBC,CAAjB,EAA8C;UAC5C,MAAMI,GAAG,GAAGJ,OAAO,CAACF,GAARE,CAAYE,GAAG,CAACC,KAAhBH,EAAuBD,GAAvBC,CAAZ;UACA,OAAO,OAAOI,GAAP,KAAe,UAAf,GACHA,GAAG,CAACC,IAAJD,CAASF,GAAG,CAACC,KAAbC,CADG,GAEHA,GAFJ;QAGD;MACF;IAZoB;;IAcvBE,wBAAwB,CAAEZ,MAAF,EAAUK,GAAV,EAAe;MACrC,MAAMQ,UAAU,GAAGP,OAAO,CAACM,wBAARN,CAAiCN,MAAjCM,EAAyCD,GAAzCC,CAAnB;MACA,IAAIO,UAAJ,EAAgB,OAAOA,UAAP,CAFqB,CAIrC;;MACA,KAAK,MAAML,GAAX,IAAkBP,IAAlB,EAAwB;QACtB,IAAI,CAACO,GAAG,CAACC,KAAT,EAAgB;QAChB,MAAMI,UAAU,GAAGP,OAAO,CAACM,wBAARN,CAAiCE,GAAG,CAACC,KAArCH,EAA4CD,GAA5CC,CAAnB;QACA,IAAIO,UAAJ,EAAgB,OAAOA,UAAP;MARmB,EAUrC;;;MACA,KAAK,MAAML,GAAX,IAAkBP,IAAlB,EAAwB;QACtB,IAAIa,GAAG,GAAGN,GAAG,CAACC,KAAJD,IAAaO,MAAM,CAACC,cAAPD,CAAsBP,GAAG,CAACC,KAA1BM,CAAvB;;QACA,OAAOD,GAAP,EAAY;UACV,MAAMD,UAAU,GAAGP,OAAO,CAACM,wBAARN,CAAiCQ,GAAjCR,EAAsCD,GAAtCC,CAAnB;UACA,IAAIO,UAAJ,EAAgB,OAAOA,UAAP;UAChBC,GAAG,GAAGC,MAAM,CAACC,cAAPD,CAAsBD,GAAtBC,CAAND;QACD;MACF;;MACD,OAAOG,SAAP;IACD;;EAlCsB,CAAlB,CAAP;AAoCD","names":["useForwardRef","target","refs","arguments","Proxy","get","key","Reflect","has","ref","value","val","bind","getOwnPropertyDescriptor","descriptor","obj","Object","getPrototypeOf","undefined"],"sources":["../../src/composables/forwardRef.ts"],"sourcesContent":["import type { Ref, UnwrapRef } from 'vue'\nimport type { UnionToIntersection } from '@/util'\n\nexport function useForwardRef<T extends {}, U extends Ref<{} | undefined>[]> (\n  target: T,\n  ...refs: U\n): T & UnwrapRef<UnionToIntersection<U[number]>> {\n  return new Proxy(target, {\n    get (target, key) {\n      if (Reflect.has(target, key)) {\n        return Reflect.get(target, key)\n      }\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          const val = Reflect.get(ref.value, key)\n          return typeof val === 'function'\n            ? val.bind(ref.value)\n            : val\n        }\n      }\n    },\n    getOwnPropertyDescriptor (target, key) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key)\n      if (descriptor) return descriptor\n\n      // Check each ref's own properties\n      for (const ref of refs) {\n        if (!ref.value) continue\n        const descriptor = Reflect.getOwnPropertyDescriptor(ref.value, key)\n        if (descriptor) return descriptor\n      }\n      // Recursive search up each ref's prototype\n      for (const ref of refs) {\n        let obj = ref.value && Object.getPrototypeOf(ref.value)\n        while (obj) {\n          const descriptor = Reflect.getOwnPropertyDescriptor(obj, key)\n          if (descriptor) return descriptor\n          obj = Object.getPrototypeOf(obj)\n        }\n      }\n      return undefined\n    },\n  }) as any\n}\n"]},"metadata":{},"sourceType":"module"}