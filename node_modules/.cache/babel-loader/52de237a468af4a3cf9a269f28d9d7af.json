{"ast":null,"code":"import { resolveDirective as _resolveDirective, createVNode as _createVNode } from \"vue\"; // Components\n\nimport { VTimelineDivider } from \"./VTimelineDivider.mjs\"; // Composables\n\nimport { IconValue } from \"../../composables/icons.mjs\";\nimport { makeElevationProps } from \"../../composables/elevation.mjs\";\nimport { makeRoundedProps } from \"../../composables/rounded.mjs\";\nimport { makeSizeProps } from \"../../composables/size.mjs\";\nimport { makeTagProps } from \"../../composables/tag.mjs\"; // Utilities\n\nimport { ref, watch } from 'vue';\nimport { convertToUnit, defineComponent, useRender } from \"../../util/index.mjs\";\nimport { makeDimensionProps, useDimension } from \"../../composables/dimensions.mjs\";\nexport const VTimelineItem = defineComponent({\n  name: 'VTimelineItem',\n  props: {\n    density: String,\n    dotColor: String,\n    fillDot: Boolean,\n    hideDot: Boolean,\n    hideOpposite: {\n      type: Boolean,\n      default: undefined\n    },\n    icon: IconValue,\n    iconColor: String,\n    ...makeRoundedProps(),\n    ...makeElevationProps(),\n    ...makeSizeProps(),\n    ...makeTagProps(),\n    ...makeDimensionProps()\n  },\n\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const {\n      dimensionStyles\n    } = useDimension(props);\n    const dotSize = ref(0);\n    const dotRef = ref();\n    watch(dotRef, newValue => {\n      var _newValue$$el$querySe, _newValue$$el$querySe2;\n\n      if (!newValue) return;\n      dotSize.value = (_newValue$$el$querySe = (_newValue$$el$querySe2 = newValue.$el.querySelector('.v-timeline-divider__dot')) == null ? void 0 : _newValue$$el$querySe2.getBoundingClientRect().width) != null ? _newValue$$el$querySe : 0;\n    }, {\n      flush: 'post'\n    });\n    useRender(() => {\n      var _slots$default, _slots$opposite;\n\n      return _createVNode(\"div\", {\n        \"class\": ['v-timeline-item', {\n          'v-timeline-item--fill-dot': props.fillDot\n        }],\n        \"style\": {\n          '--v-timeline-dot-size': convertToUnit(dotSize.value)\n        }\n      }, [_createVNode(\"div\", {\n        \"class\": \"v-timeline-item__body\",\n        \"style\": dimensionStyles.value\n      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), _createVNode(VTimelineDivider, {\n        \"ref\": dotRef,\n        \"hideDot\": props.hideDot,\n        \"icon\": props.icon,\n        \"iconColor\": props.iconColor,\n        \"size\": props.size,\n        \"elevation\": props.elevation,\n        \"dotColor\": props.dotColor,\n        \"fillDot\": props.fillDot,\n        \"rounded\": props.rounded\n      }, {\n        default: slots.icon\n      }), props.density !== 'compact' && _createVNode(\"div\", {\n        \"class\": \"v-timeline-item__opposite\"\n      }, [!props.hideOpposite && ((_slots$opposite = slots.opposite) == null ? void 0 : _slots$opposite.call(slots))])]);\n    });\n    return {};\n  }\n\n});","map":{"version":3,"mappings":"0FAAA;;SACSA,wB,0BAET;;SACSC,iB;SACAC,0B;SACAC,wB;SACAC,qB;SACAC,oB,6BAET;;AAEA,SAASC,GAAT,EAAcC,KAAd,QAA2B,KAA3B;SACSC,eAAeC,iBAAiBC,iB;SAChCC,oBAAoBC,oB;AAE7B,OAAO,MAAMC,aAAa,GAAGJ,eAAe,CAAC;EAC3CK,IAAI,EAAE,eADqC;EAG3CC,KAAK,EAAE;IACLC,OAAO,EAAEC,MADJ;IAELC,QAAQ,EAAED,MAFL;IAGLE,OAAO,EAAEC,OAHJ;IAILC,OAAO,EAAED,OAJJ;IAKLE,YAAY,EAAE;MACZC,IAAI,EAAEH,OADM;MAEZI,OAAO,EAAEC;IAFG,CALT;IASLC,IAAI,EAAEzB,SATD;IAUL0B,SAAS,EAAEV,MAVN;IAYL,GAAGd,gBAAgB,EAZd;IAaL,GAAGD,kBAAkB,EAbhB;IAcL,GAAGE,aAAa,EAdX;IAeL,GAAGC,YAAY,EAfV;IAgBL,GAAGM,kBAAkB;EAhBhB,CAHoC;;EAsB3CiB,KAAK,CAAEb,KAAF,QAAoB;IAAA,IAAX;MAAEc;IAAF,IAAWC;IACvB,MAAM;MAAEC;IAAF,IAAsBnB,YAAY,CAACG,KAAD,CAAxC;IAEA,MAAMiB,OAAO,GAAG1B,GAAG,CAAC,CAAD,CAAnB;IACA,MAAM2B,MAAM,GAAG3B,GAAG,EAAlB;IACAC,KAAK,CAAC0B,MAAD,EAASC,QAAQ,IAAI;MAAA;;MACxB,IAAI,CAACA,QAAL,EAAe;MACfF,OAAO,CAACG,KAARH,sDAAgBE,QAAQ,CAACE,GAATF,CAAaG,aAAbH,CAA2B,0BAA3BA,CAAhB,qBAAgBI,uBAAwDC,qBAAxD,GAAgFC,KAAhG,oCAAyG,CAAzGR;IAFG,GAGF;MACDS,KAAK,EAAE;IADN,CAHE,CAALlC;IAOAG,SAAS,CAAC;MAAA;;MAAA;QAAA,SAEC,CACL,iBADK,EAEL;UACE,6BAA6BK,KAAK,CAACI;QADrC,CAFK,CAFD;QAAA,SAQC;UACL,yBAAyBX,aAAa,CAACwB,OAAO,CAACG,KAAT;QADjC;MARD;QAAA,SAaE,uBAbF;QAAA,SAcIJ,eAAe,CAACI;MAdpB,sBAgBFN,KAAK,CAACL,OAhBJ,qBAgBFkB,0BAhBE;QAAA,OAoBET,MApBF;QAAA,WAqBMlB,KAAK,CAACM,OArBZ;QAAA,QAsBGN,KAAK,CAACW,IAtBT;QAAA,aAuBQX,KAAK,CAACY,SAvBd;QAAA,QAwBGZ,KAAK,CAAC4B,IAxBT;QAAA,aAyBQ5B,KAAK,CAAC6B,SAzBd;QAAA,YA0BO7B,KAAK,CAACG,QA1Bb;QAAA,WA2BMH,KAAK,CAACI,OA3BZ;QAAA,WA4BMJ,KAAK,CAAC8B;MA5BZ,GA6BK;QAAErB,OAAO,EAAEK,KAAK,CAACH;MAAjB,CA7BL,GAgCJX,KAAK,CAACC,OAAND,KAAkB,SAAlBA;QAAA,SACW;MADX,IAEI,CAACA,KAAK,CAACO,YAAP,wBAAuBO,KAAK,CAACiB,QAA7B,qBAAuBC,2BAAvB,CAFJ,EAhCI;IAAD,EAATrC;IAwCA,OAAO,EAAP;EACD;;AA3E0C,CAAD,CAArC","names":["VTimelineDivider","IconValue","makeElevationProps","makeRoundedProps","makeSizeProps","makeTagProps","ref","watch","convertToUnit","defineComponent","useRender","makeDimensionProps","useDimension","VTimelineItem","name","props","density","String","dotColor","fillDot","Boolean","hideDot","hideOpposite","type","default","undefined","icon","iconColor","setup","slots","_ref","dimensionStyles","dotSize","dotRef","newValue","value","$el","querySelector","_newValue$$el$querySe2","getBoundingClientRect","width","flush","_slots$default","size","elevation","rounded","opposite","_slots$opposite"],"sources":["../../../src/components/VTimeline/VTimelineItem.tsx"],"sourcesContent":["// Components\nimport { VTimelineDivider } from './VTimelineDivider'\n\n// Composables\nimport { IconValue } from '@/composables/icons'\nimport { makeElevationProps } from '@/composables/elevation'\nimport { makeRoundedProps } from '@/composables/rounded'\nimport { makeSizeProps } from '@/composables/size'\nimport { makeTagProps } from '@/composables/tag'\n\n// Utilities\nimport type { PropType } from 'vue'\nimport { ref, watch } from 'vue'\nimport { convertToUnit, defineComponent, useRender } from '@/util'\nimport { makeDimensionProps, useDimension } from '@/composables/dimensions'\n\nexport const VTimelineItem = defineComponent({\n  name: 'VTimelineItem',\n\n  props: {\n    density: String as PropType<'default' | 'compact'>,\n    dotColor: String,\n    fillDot: Boolean,\n    hideDot: Boolean,\n    hideOpposite: {\n      type: Boolean,\n      default: undefined,\n    },\n    icon: IconValue,\n    iconColor: String,\n\n    ...makeRoundedProps(),\n    ...makeElevationProps(),\n    ...makeSizeProps(),\n    ...makeTagProps(),\n    ...makeDimensionProps(),\n  },\n\n  setup (props, { slots }) {\n    const { dimensionStyles } = useDimension(props)\n\n    const dotSize = ref(0)\n    const dotRef = ref<VTimelineDivider>()\n    watch(dotRef, newValue => {\n      if (!newValue) return\n      dotSize.value = newValue.$el.querySelector('.v-timeline-divider__dot')?.getBoundingClientRect().width ?? 0\n    }, {\n      flush: 'post',\n    })\n\n    useRender(() => (\n      <div\n        class={[\n          'v-timeline-item',\n          {\n            'v-timeline-item--fill-dot': props.fillDot,\n          },\n        ]}\n        style={{\n          '--v-timeline-dot-size': convertToUnit(dotSize.value),\n        }}\n      >\n        <div\n          class=\"v-timeline-item__body\"\n          style={ dimensionStyles.value }\n        >\n          { slots.default?.() }\n        </div>\n\n        <VTimelineDivider\n          ref={ dotRef }\n          hideDot={ props.hideDot }\n          icon={ props.icon }\n          iconColor={ props.iconColor }\n          size={ props.size }\n          elevation={ props.elevation }\n          dotColor={ props.dotColor }\n          fillDot={ props.fillDot }\n          rounded={ props.rounded }\n          v-slots={{ default: slots.icon }}\n        />\n\n        { props.density !== 'compact' && (\n          <div class=\"v-timeline-item__opposite\">\n            { !props.hideOpposite && slots.opposite?.() }\n          </div>\n        ) }\n      </div>\n    ))\n\n    return {}\n  },\n})\n"]},"metadata":{},"sourceType":"module"}